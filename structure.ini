malaria-classification/
├── README.md
├── requirements.txt
├── .gitignore
│
├── data/
│   ├── raw/                    # original downloaded images (Parasitized/, Uninfected/)
│   ├── processed/              # splits & any cached transforms
│   │   ├── train/
│   │   │   ├── Parasitized/
│   │   │   └── Uninfected/
│   │   ├── val/
│   │   │   ├── Parasitized/
│   │   │   └── Uninfected/
│   │   └── test/
│   │       ├── Parasitized/
│   │       └── Uninfected/
│   └── scripts/
│       └── download_data.py    # script to fetch & unzip dataset
│
├── notebooks/
│   └── EDA.ipynb               # exploratory data analysis & sample-visualizations
│
├── src/
│   ├── datamodule.py           # Dataset, DataLoader, transforms setup
│   ├── model.py                # CNN definition (nn.Module)
│   ├── train.py                # training loop (Task 1 & 2)
│   ├── evaluate.py             # evaluation metrics & plotting functions
│   ├── utils.py                # helper functions (seed setting, metrics, confusion matrix)
│   └── config.py               # hyperparameters & paths
│
├── outputs/
│   ├── models/                 # saved .pth checkpoint(s)
│   ├── logs/                   # TensorBoard logs (if used)
│   └── figures/                # loss/accuracy curves, confusion matrices
│
└── scripts/
    └── run_experiment.py       # python script to launch training/eval





Here’s a sensible order to tackle the files—each builds on the previous—along with a brief “why” for each step:

config.py
• Define all your hyperparameters, file-paths, random seeds, batch-sizes, learning rates, augmentation flags, etc.
• Why first? So that every other module can import unified settings instead of hard-coding values.

utils.py
• Implement generic utilities:

set_seed(seed)

Device selection (CPU vs GPU)

Metric functions (accuracy, precision, recall, F1, ROC-AUC)

Confusion-matrix plotting helper
• Why next? Both training and evaluation code will need these helpers.

datamodule.py
• Build your MalariaDataModule (or plain PyTorch Dataset/DataLoader functions) using transforms and splits.
• Why now? Your training loop and any quick data checks need a working data pipeline.

model.py
• Define your SimpleCNN class.
• Why here? You need the model class before you can wire up training or evaluation.

train.py
• Write the full training loop:

Instantiate MalariaDataModule, call setup()

Instantiate SimpleCNN + optimizer + loss

Loop over epochs: train & validate, log metrics, save best checkpoints
• Why now? You now have config, data, model, and utils in place to put it all in motion.

evaluate.py
• Load a saved checkpoint, run on validation/test set, compute and print all metrics, produce final loss/accuracy curves and confusion matrix plots.
• Why last? You need trained weights from train.py and the metrics/utils code to generate your final reports.